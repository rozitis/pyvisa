.. -*- mode: rst; coding: iso-8859-1; ispell-local-dictionary: "british"; -*-
.. 
..   vpp43.txt - VISA VPP-4.3.2 functions documentation
.. 
..   Copyright © 2005 Gregor Thalhammer <gth@users.sourceforge.net>,
..                    Torsten Bronger <bronger@physik.rwth-aachen.de>.
.. 
..   This file is part of pyvisa.
.. 
..   pyvisa is free software; you can redistribute it and/or modify it under
..   the terms of the GNU General Public License as published by the Free
..   Software Foundation; either version 2 of the License, or (at your option)
..   any later version.
.. 
..   pyvisa is distributed in the hope that it will be useful, but WITHOUT ANY
..   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
..   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
..   details.
.. 
..   You should have received a copy of the GNU General Public License along
..   with pyvisa; if not, write to the Free Software Foundation, Inc., 59
..   Temple Place, Suite 330, Boston, MA 02111-1307 USA
.. 

=========================================
The VISA low-level implementation
=========================================

--------------------------
Part of the PyVISA package
--------------------------

:Date: $Date$
:Version: $Revision$
:Author: Torsten Bronger <bronger@physik.rwth-aachen.de>
:Abstract: This document covers the ``vpp43.py`` module, which is part of the
  PyVISA_ package.  This module implements thin wrappers around all functions
  defined in the `VISA specification`_.  Thus it enables the programmer to
  communicate with measurement and test devices via GPIB, RS232, USB etc.

.. _PyVISA: http://sourceforge.net/projects/pyvisa/
.. _`VISA specification`: http://www.ivifoundation.org/Downloads/Class%20Specifications/vpp43.doc


Overview
===========

The programming of measurement instruments can be real pain.  There are many
different protocols, sent over many different interface and bus systems.  For
every programming language you want to use, you have to find libraries that
support both your device and its bus system.

In order to ease this unfortunate situation, the VISA [#]_ specification was
defined in the middle of the 90ies.  Today VISA is implemented on all
significant operating systems.  A couple of vendors offer VISA libraries,
albeit mostly in binary form.  These libraries work together with arbitrary
peripherical devices, although they may be limited to certain interface
devices, such as the vendor's GPIB card.

.. [#] Virtual Instrument Software Architecture

The VISA specification has explicit bindings to Visual Basic, C, and G
(LabVIEW's graphical language).  However, you can use VISA with any language
capable of calling functions in a DLL.  Python is such a language.


VISA and Python
====================

Python has a couple of features that make it very interesting for measurement
controlling:

* Python is an easy-to-learn scripting language with short development cycles.

* It represents a high abstraction level [#]_, which perfectly blends with the
  abstraction level of measurement programs.

* It has a very rich set of native libraries, including numerical and plotting
  modules for data analysis and visualisation.

* A large set of books (in many languages) and on-line publications is
  available.

* You can download it for free at http://www.python.org.

.. [#] For example, you don't need to care about the underlying operating
       system with all its peculiarities.

The PyVISA package is a VISA binding for Python.  It is implemented in two
layers.  This document describes its lower level ``vpp43.py``, which directly
accesses the VISA functions from Python.  On top of it, an object-oriented
Python module has been created called ``visa.py``.  In case of doubt, use
``visa.py`` because it is easier and more convenient. ``vpp43.py`` is only for
people who need full control or the official VISA functions for some reason.


Prerequisites
================

The PyVISA package doesn't include a VISA library itself.  You have to download
it from one of the VISA vendors, e.g. `National Instruments' VISA pages`_.
Please install it properly before you proceed.

.. _`National Instruments' VISA pages`: http://ni.com/visa/

For Windows, PyVISA expects a file called ``visa32.dll`` in the PATH.  For
Linux, it's the file ``/usr/local/vxipnp/linux/bin/libvisa.so.7`` by default.


The PyVISA functions
==========================


assert_interrupt_signal
.......................

Asserts the specified device interrupt or signal.

:Call: assert_interrupt_signal(vi, mode, status_id)
:VISA name: viAssertIntrSignal
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `mode` : integer
        This specifies how to assert the interrupt.
    `status_id` : integer
        This is the status value to be presented during an interrupt
	acknowledge cycle.
:Return values:
    None.


assert_trigger
..............

Assert software or hardware trigger.

:Call: assert_trigger(vi, protocol)
:VISA name: viAssertTrigger
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `protocol` : integer
        Trigger protocol to use during assertion.  Valid values are:
	``VI_TRIG_PROT_DEFAULT``, ``VI_TRIG_PROT_ON``, ``VI_TRIG_PROT_OFF``,
	and ``VI_TRIG_PROT_SYNC``.
:Return values:
    None.


assert_utility_signal
.....................

Asserts the specified utility bus signal.

:Call: assert_utility_signal(vi, line)
:VISA name: viassert_utility_signal
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `line` : integer
        Specifies the utility bus signal to assert.
:Return values:
    None.

    visa_library().viAssertUtilSignal(vi, line)


buffer_read
...........

Similar to `read`_, except that the operation uses the formatted I/O read
buffer for holding data read from the device.

:Call: buffer = buffer_read(vi, count)
:VISA name: viBufRead
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `count` : integer
        Maximal number of bytes to be read.
:Return values:
    `buffer` : string
        The buffer with the received data from device.


buffer_write
............

Similar to `write`_, except the data is written to the formatted I/O write
buffer rather than directly to the device.

:Call: return_count = buffer_write(vi, buffer)
:VISA name: viBufWrite
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `buffer` : string
        The data block to be sent to device.
:Return values:
    `return_count` : integer
        The number of bytes actually transferred.


clear
.....

Clear a device.

:Call: clear(vi)
:VISA name: viClear
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
:Return values:
    None.


close
.....

Close the specified session, event, or find list.

:Call: close(vi)
:VISA name: viClose
:Parameters:
    `vi` : ViSession, ViEvent, or ViFindList
        Unique logical identifier to a session, event, or find list.
:Return values:
    None.


disable_event
.............

Disable notification of an event type by the specified mechanisms.

:Call: disable_event(vi, event_type, mechanism)
:VISA name: viDisableEvent
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `event_type` : integer
        Logical event identifier.
    `mechanism` : integer
        Specifies event handling mechanisms to be disabled. The queuing
	mechanism is disabled by specifying ``VI_QUEUE``, and the callback
	mechanism is disabled by specifying ``VI_HNDLR`` or
	``VI_SUSPEND_HNDLR``. It is possible to disable both mechanisms
	simultaneously by specifying ``VI_ALL_MECH``.
:Return values:
    None.


discard_events
..............

Discard event occurrences for specified event types and mechanisms in a
session.

:Call: discard_events(vi, event_type, mechanism)
:VISA name: vidiscard_events
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `event_type` : integer
        Logical event identifier.
    `mechanism` : integer
        Specifies the mechanisms for which the events are to be discarded.  The
	``VI_QUEUE`` value is specified for the queuing mechanism and the
	``VI_SUSPEND_HNDLR`` value is specified for the pending events in the
	callback mechanism.  It is possible to specify both mechanisms
	simultaneously by specifying ``VI_ALL_MECH``.
:Return values:
    None.


enable_event
............

Enable notification of a specified event.

:Call: enable_event(vi, event_type, mechanism, context)
:VISA name: viEnableEvent
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `event_type` : integer
        Logical event identifier.
    `mechanism` : integer
        Specifies event handling mechanisms to be enabled.  The queuing
	mechanism is enabled by specifying ``VI_QUEUE``, and the callback
	mechanism is enabled by specifying ``VI_HNDLR`` or
	``VI_SUSPEND_HNDLR``.  It is possible to enable both mechanisms
	simultaneously by specifying bit-wise "or" of ``VI_QUEUE`` and one of
	the two mode values for the callback mechanism.
    `context` : integer : optional
        According to the VISA specification, this must be ``Vi_NULL`` always.
	(This is also the default value, of course.)
:Return values:
    None.


find_next
.........

:Call: instrument_description = find_next(find_list)
:VISA name: vifind_next
:Parameters:
    `find_list` : ViFindList
        Describes a find list.  This parameter must be created by
	`find_resources`_.
:Return values:
    `instrument_description` : string
        Returns a string identifying the location of a device. Strings can then
	be passed to `open`_ to establish a session to the given device.


find_resources
..............

:Call: find_list, return_counter, instrument_description =
       find_resources(session, regular_expression)
:VISA name: viFindRsrc
:Parameters:
    `session` : ViSession
        Resource Manager session (should always be the Default Resource Manager
	for VISA returned from `open_default_resource_manager`_).
    `regular_expression` : integer
        This is a regular expression followed by an optional logical
	expression.  The grammar for this expression is given below.
:Return values:
    `find_list` : ViFindList
        Returns a handle identifying this search session. This handle will be
	used as an input in `find_next`_.
    `return_counter` : integer
        Number of matches.
    `instrument_description` : string
        Returns a string identifying the location of a device. Strings can then
        be passed to `open`_ to establish a session to the given device.


flush
.....

Manually flush the specified buffers associated with formatted I/O operations
and/or serial communication.

:Call: flush(vi, mask)
:VISA name: viFlush
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `mask` : integer
        Specifies the action to be taken with flushing the buffer.
:Return values:
    None.


get_attribute
.............

Retrieve the state of an attribute.

:Call: attribute_state = get_attribute(vi, attribute)
:VISA name: viGetAttribute
:Parameters:
    `vi` : ViSession, ViEvent, or ViFindList
        Unique logical identifier to a session.
    `attribute` : integer
        Session, event, or find list attribute for which the state query is
	made.
:Return values:
    `attribute_state` : integer
        The state of the queried attribute for a specified resource. The
	interpretation of the returned value is defined by the individual
	resource.


gpib_command
............

:Call: return_count = gpib_command(vi, buffer)
:VISA name: viGpibCommand
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `buffer` : string
:Return values:
    `return_count` : integer

    return_count = ViUInt32()
    visa_library().viGpibCommand(vi, buffer, len(buffer), byref(return_count))
    return return_count.value


gpib_control_atn
................

:Call: gpib_control_atn(vi, mode)
:VISA name: viGpibControlATN
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `mode` : integer
:Return values:
    None.

    visa_library().viGpibControlATN(vi, ViUInt16(mode))


gpib_control_ren
................

:Call: gpib_control_ren(vi, mode)
:VISA name: viGpibControlREN
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `mode` : integer
:Return values:
    None.

    visa_library().viGpibControlREN(vi, mode)


gpib_pass_control
.................

:Call: gpib_pass_control(vi, primary_address, secondary_address)
:VISA name: viGpibPassControl
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `primary_address` : integer
    `secondary_address` : integer
:Return values:
    None.

    visa_library().viGpibPassControl(vi, primary_address, secondary_address)


gpib_send_ifc
.............

:Call: gpib_send_ifc(vi)
:VISA name: viGpibSendIFC
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
:Return values:
    None.

    visa_library().viGpibSendIFC(vi)


in_8, in_16, in_32
..................

Read in an 8-bit, 16-bit, or 32-bit value from the specified memory space and
offset.

:Call: | value_8 = in_8(vi, space, offset)
       | value_16 = in_16(vi, space, offset)
       | value_32 = in_32(vi, space, offset)
:VISA name: viIn8, viIn16, viIn32
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `space` : integer
        Specifies the address space.
    `offset` : integer
        Offset in bytes of the address or register from which to read.
:Return values:
    `value_8`, `value_16`, `value_32` : integer
        Data read from bus (8 bits for `in_8`, 16 bits for `in_16`, and 32
	bits for `in_32`).


install_handler
...............

Install handlers for event callbacks.

:Call: install_handler(vi, event_type, handler, user_handle)
:VISA name: viInstallHandler
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `event_type` : integer
        Logical event identifier.
    `handler` : ViHndlr
        Interpreted as a valid reference to a handler to be installed by a
	client application.
    `user_handle` : integer : optional
        A value specified by an application that can be used for identifying
	handlers uniquely for an event type.  It defaults to 0.
:Return values:
    None.


lock
....

Establish an access mode to the specified resource.

:Call: access_key = lock(vi, lock_type, timeout, requested_key)
:VISA name: viLock
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `lock_type` : integer
        Specifies the type of lock requested, which can be either
	``VI_EXCLUSIVE_LOCK`` or ``VI_SHARED_LOCK``.
    `timeout` : integer
        Absolute time period in milliseconds that a resource waits to get
	unlocked by the locking session before returning this operation with an
	error.
    `requested_key` : string : optional
        This parameter is not used if `lock_type` is ``VI_EXCLUSIVE_LOCK``
	(exclusive locks).  When trying to lock the resource as
	``VI_SHARED_LOCK`` (shared), you can either omit it so that VISA
	generates an `access_key` for the session, or you can suggest an
	`access_key` to use for the shared lock.
:Return values:
    `access_key` : string : optional
        This value is ``None`` if `lock_type` is ``VI_EXCLUSIVE_LOCK``
	(exclusive locks).  When trying to lock the resource as
	``VI_SHARED_LOCK`` (shared), the function returns a unique access key
	for the lock if the operation succeeds.  This `access_key` can then be
	passed to other sessions to share the lock.


map_address
...........

Map the specified memory space into the process's address space.

:Call: map_address(vi, map_space, map_base, map_size, access, suggested)
:VISA name: vimap_address
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    address = ViAddr()
    visa_library().viMapAddress(vi, map_space, map_base, map_size, access,
				suggested, byref(address))
    return address.value


map_trigger
...........

Map the specified trigger source line to the specified destination line.

:Call: map_trigger(vi, trigger_source, trigger_destination, mode)
:VISA name: viMapTrigger
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `trigger_source` : integer
        Source line from which to map.
    `trigger_destination` : integer
        Destination line to which to map.
    `mode` : integer
        Specifies the trigger mapping mode. This should always be VI_NULL.
:Return values:
    None.


memory_allocation
.................

:Call: memory_allocation(vi, size)
:VISA name: vimemory_allocation
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    offset = ViBusAddress()
    visa_library().viMemAlloc(vi, size, byref(offset))
    return offset.value


memory_free
...........

:Call: memory_free(vi, offset)
:VISA name: vimemory_free
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    visa_library().viMemFree(vi, offset)


move
....

Move a block of data.

:Call: move(vi, source_space, source_offset, source_width, destination_space,
	 destination_offset, destination_width, length)
:VISA name: viMove
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `source_space` : integer
        Specifies the address space of the source.
    `source_offset` : integer
        Offset in bytes of the starting address or register from which to
        read.
    `source_width` : integer
        Specifies the data width of the source.
    `destination_space` : integer
        Specifies the address space of the destination.
    `destination_offset` : integer
        Offset in bytes of the starting address or register to which to write.
    `destination_width` : integer
        Specifies the data width of the destination.
    `length` : integer
        Number of elements to transfer, where the data width of the elements to
	transfer is identical to source data width.
:Return values:
    None.


move_asynchronously
...................

Move a block of data asynchronously.

:Call: job_id = move_asynchronously(vi, source_space, source_offset,
       source_width, destination_space, destination_offset, destination_width,
       length)
:VISA name: viMoveAsync
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `source_space` : integer
        Specifies the address space of the source.
    `source_offset` : integer
        Offset in bytes of the starting address or register from which to
        read.
    `source_width` : integer
        Specifies the data width of the source.
    `destination_space` : integer
        Specifies the address space of the destination.
    `destination_offset` : integer
        Offset in bytes of the starting address or register to which to write.
    `destination_width` : integer
        Specifies the data width of the destination.
    `length` : integer
        Number of elements to transfer, where the data width of the elements to
	transfer is identical to source data width.
:Return values:
    `job_id` : ViJobId
        The job identifier of this asynchronous move operation. Each time an
        asynchronous move operation is called, it is assigned a unique job
        identifier.


move_in_8, move_in_16, move_in_32
.................................

Move a block of data from the specified address space and offset to local
memory in increments of 8, 16, or 32 bits.

:Call: | buffer_8 = move_in_8(vi, space, offset, length)
       | buffer_16 = move_in_16(vi, space, offset, length)
       | buffer_32 = move_in_32(vi, space, offset, length)
:VISA name: viMoveIn8, viMoveIn16, viMoveIn32
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `space` : integer
        Specifies the address space.
    `offset` : integer
        Offset in bytes of the starting address or register from which to
	read.
    `length` : integer
        Number of elements to transfer, where the data width of the elements to
	transfer is identical to data width (8, 16, or 32 bits).
:Return values:
    `buffer_8`, `buffer_16`, `buffer_32` : list of integers
        Data read from bus as a Python list of values.


move_out_8
..........

Move a block of data from local memory to the specified address space and
offset in increments of 8, 16, or 32 bits.

:Call: | move_out_8(vi, space, offset, length, buffer_8)
       | move_out_16(vi, space, offset, length, buffer_16)
       | move_out_32(vi, space, offset, length, buffer_32)
:VISA name: viMoveOut8, viMoveOut16, viMoveOut32
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `space` : integer
        Specifies the address space.
    `offset` : integer
        Offset in bytes of the starting address or register from which to
	write.
    `length` : integer
        Number of elements to transfer, where the data width of the elements to
	transfer is identical to data width (8, 16, or 32 bits).
    `buffer_8`, `buffer_16`, `buffer_32` : sequence of integers
        Data to write to bus.  This may be a list or a tuple, however in any
	case in must contain integers.
:Return values:
    None.


open
....

Open a session to the specified device.

:Call: vi = open(session, resource_name, access_mode, timeout)
:VISA name: viOpen
:Parameters:
    `session` : ViSession
        Resource Manager session (should always be the Default Resource Manager
	for VISA returned from `open_default_resource_manager`_).
    `resource_name` : string
        Unique symbolic name of a resource.
    `access_mode` : integer : optional
        Defaults to ``VI_NO_LOCK``.  Specifies the modes by which the resource
	is to be accessed.  The value ``VI_EXCLUSIVE_LOCK`` is used to acquire
	an exclusive lock immediately upon opening a session; if a lock cannot
	be acquired, the session is closed and an error is returned.  The value
	``VI_LOAD_CONFIG`` is used to configure attributes to values specified
	by some external configuration utility; if this value is not used, the
	session uses the default values provided by this
	specification.  Multiple access modes can be used simultaneously by
	specifying a "bitwise OR" of the above values.
    `timeout` : integer : optional
        If the `access_mode` parameter requests a lock, then this parameter
	specifies the absolute time period in milliseconds that the resource
	waits to get unlocked before this operation returns an error;
	otherwise, this parameter is ignored.  Defaults to
	``VI_TMO_IMMEDIATE``.
:Return values:
    `vi` : ViSession
        Unique logical identifier reference to a session.


open_default_resource_manager
.............................

Return a session to the Default Resource Manager resource.

:Call: session = open_default_resource_manager()
:VISA name: viOpenDefaultRM
:Parameters:
    None.
:Return values:
    `session` : ViSession
        Unique logical identifier to a Default Resource Manager session.

get_default_resource_manager
............................

This is a deprecated alias for `open_default_resource_manager`_.


out_8, out_16, out_32
.....................

:Call: | out_8(vi, space, offset, value_8)
       | out_16(vi, space, offset, value_16)
       | out_32(vi, space, offset, value_32)
:VISA name: viOut8, viOut16, viOut32
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `space` : integer
        Specifies the address space.
    `offset` : integer
        Offset in bytes of the address or register to which to write.
    `value_8`, `value_16`, `value_32`: integer
        Data to write to bus (8 bits for out_8, 16 bits for out_16, and 32 bits
	for out_32).
:Return values:
    None.


parse_resource
..............

Parse a resource string to get the interface information.

:Call: interface_type, interface_board_number = parse_resource(session,
       resource_name)
:VISA name: viParseRsrc
:Parameters:
    `session` : ViSession
        Resource Manager session (should always be the Default Resource Manager
	for VISA returned from `open_default_resource_manager`_).
    `resource_name` : string
        Unique symbolic name of a resource.
:Return values:
    `interface_type` : integer
        Interface type of the given resource string.
    `interface_board_number` : integer
        Board number of the interface of the given resource string.


parse_resource_extended
.......................

Parse a resource string to get extended interface information.

:Call: interface_type, interface_board_number, resource_class,
       unaliased_expanded_resource_name, alias_if_exists =
       parse_resource_extended(session, resource_name)
:VISA name: viParseRsrcEx
:Parameters:
    `session` : ViSession
        Resource Manager session (should always be the Default Resource Manager
	for VISA returned from `open_default_resource_manager`_).
    `resource_name` : string
:Return values:
    `interface_type` : integer
        Interface type of the given resource string.
    `interface_board_number` : integer
        Board number of the interface of the given resource string.
    `resource_class` : string
        Specifies the resource class (for example "INSTR") of the given
	resource string.
    `unaliased_expanded_resource_name` : string
        This is the expanded version of the given resource string. The format
	should be similar to the VISA-defined canonical resource name.
    `alias_if_exists` : string
        Specifies the user-defined alias for the given resource string, if a
	VISA implementation allows aliases and an alias exists for the given
	resource string.


peek_8
......

:Call: peek_8(vi, address)
:VISA name: vipeek_8
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    value_8 = ViUInt8()
    visa_library().viPeek8(vi, address, byref(value_8))
    return value_8.value


peek_16
.......

:Call: peek_16(vi, address)
:VISA name: vipeek_16
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    value_16 = ViUInt16()
    visa_library().viPeek16(vi, address, byref(value_16))
    return value_16.value


peek_32
.......

:Call: peek_32(vi, address)
:VISA name: vipeek_32
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    value_32 = ViUInt32()
    visa_library().viPeek32(vi, address, byref(value_32))
    return value_32.value


poke_8
......

:Call: poke_8(vi, address, value_8)
:VISA name: vipoke_8
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    visa_library().viPoke8(vi, address, value_8)


poke_16
.......

:Call: poke_16(vi, address, value_16)
:VISA name: vipoke_16
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    visa_library().viPoke16(vi, address, value_16)


poke_32
.......

:Call: poke_32(vi, address, value_32)
:VISA name: vipoke_32
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    visa_library().viPoke32(vi, address, value_32)


printf
......

Convert, format, and send the parameters ``...`` to the device as specified by
the format string.

.. Warning::
    The current implementation only supports the following C data types:
    ``long``, ``double`` and ``char*`` (strings).  Thus, you can only use these
    three data types in format strings for printf, scanf and the like.

:Call: printf(vi, write_format, ...)
:VISA name: viPrintf
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `write_format` : string
        String describing the format for arguments.
    `...` : integers, floats, or strings
        Arguments sent to the device according to `write_format`.
:Return values:
    None.


queryf
......

Perform a formatted write and read through a single operation invocation.

.. Warning::
    The current implementation only supports the following C data types:
    ``long``, ``double`` and ``char*`` (strings).  Thus, you can only use these
    three data types in format strings for printf, scanf and the like.

:Call: value1, value2, ... = queryf(vi, write_format, read_format, (...), ...,
       maximal_string_length = 1024)
:VISA name: viQueryf
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `write_format` : string
        String describing the format for arguments.
    `read_format` : string
        String describing the format for arguments.
    `(...)` : tuple of integers, floats, or strings
        Arguments sent to the device according to `write_format`.  May be
        ``None``.
    `...` : integers, floats, or strings
        Arguments to be read from the device according to `read_format`.  It's
	totally insignificant which values they have, they serve just as a
	cheap way to determine what types are to be expected.  So actually this
	argument list shouldn't be necessary, but with the current
	implementation, it is, sorry.

        These arguments may be (however needn't be) the same names used for
	storing the result values.  Alternatively, you can give literals.
    `maximal_string_length` : integer : keyword argument
        The maximal length assumed for string result arguments.  Note that
	string results must *never* exceed this length.  It defaults to 1024.
:Return values:
    `value1`, `value2`, ... : integers, floats, or strings
        Arguments read from the device according to `read_format`.  Of course,
	this must be the same sequence (as far as data types are concerned) as
	the given argument list `...` above.


read
....

Read data from device synchronously.

:Call: buffer = read(vi, count)
:VISA name: viRead
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `count` : integer
        Maximal number of bytes to be read.
:Return values:
    `buffer` : string
        Represents the buffer with the received data from device.


read_asynchronously
...................

Read data from device asynchronously.

:Call: buffer, job_id = read_asynchronously(vi, count)
:VISA name: viReadAsync
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `count` : integer
        Maximal number of bytes to be read.
:Return values:
    `buffer` : string
        Represents the buffer with the received data from device.
    `job_id` : ViJobId
        Represents the location of a variable that will be set to the job
	identifier of this asynchronous read operation.


read_stb
........

Read a status byte of the service request.

:Call: status = read_stb(vi)
:VISA name: viReadSTB
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
:Return values:
    `status` : integer
        Service request status byte.


read_to_file
............

Read data synchronously, and store the transferred data in a file.

:Call: return_count = read_to_file(vi, filename, count)
:VISA name: viread_to_file
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `file_name` : string
        Name of file to which data will be written.
    `count` : integer
        Maximal number of bytes to be read.
:Return values:
    `return_count` : integer
        Number of bytes actually transferred.


scanf
.....

Read, convert, and format data using the format specifier.  Store the formatted
data in the given optional parameters.

.. Warning::
    The current implementation only supports the following C data types:
    ``long``, ``double`` and ``char*`` (strings).  Thus, you can only use these
    three data types in format strings for printf, scanf and the like.

:Call: value1, value2, ... = scanf(vi, read_format, ..., maximal_string_length
       = 1024)
:VISA name: viScanf
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `read_format` : string
        String describing the format for arguments.
    `...` : integers, floats, or strings
        Arguments to be read from the device according to `read_format`.  It's
	totally insignificant which values they have, they serve just as a
	cheap way to determine what types are to be expected.  So actually this
	argument list shouldn't be necessary, but with the current
	implementation, it is, sorry.

        These arguments may be (however needn't be) the same names used for
	storing the result values.  Alternatively, you can give literals.
    `maximal_string_length` : integer : keyword argument
        The maximal length assumed for string result arguments.  Note that
	string results must *never* exceed this length.  It defaults to 1024.
:Return values:
    `value1`, `value2`, ... : integers, floats, or strings
        Arguments read from the device according to `read_format`.  Of course,
	this must be the same sequence (as far as data types are concerned) as
	the given argument list `...` above.


set_attribute
.............

Set the state of an attribute.

:Call: set_attribute(vi, attribute, attribute_state)
:VISA name: viSetAttribute
:Parameters:
    `vi` : ViSession, ViEvent, or ViFindList
        Unique logical identifier to a session.
    `attribute` : integer
        Session, event, or find list attribute for which the state is
	modified.
    `attribute_state` : integer
        The state of the attribute to be set for the specified resource.  The
	interpretation of the individual attribute value is defined by the
	resource.
:Return values:
    None.


set_buffer
..........

Set the size for the formatted I/O and/or serial communication buffer(s).

:Call: set_buffer(vi, mask, size)
:VISA name: viSetBuf
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `mask` : integer
        Specifies the type of buffer.
    `size` : integer
        The size to be set for the specified buffer(s).
:Return values:
    None.


sprintf
.......

Same as `printf`_, except the data is written to a user-specified buffer rather
than the device.

.. Warning::
    The current implementation only supports the following C data types:
    ``long``, ``double`` and ``char*`` (strings).  Thus, you can only use these
    three data types in format strings for printf, scanf and the like.

:Call: buffer = sprintf(vi, write_format, ..., buffer_length = 1024)
:VISA name: viSPrintf
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `write_format` : string
        String describing the format for arguments.
    `...` : integers, floats, or strings
        Arguments sent to the buffer according to `write_format`.
    `buffer_length` : integer : keyword argument
        Length of the user-specified buffer in bytes.  Defaults to 1024.
:Return values:
    `buffer` : string
        Buffer where the formatted data was written to.


sscanf
......

Same as `scanf`_, except that the data is read from a user-specified buffer
instead of a device.

.. Warning::
    The current implementation only supports the following C data types:
    ``long``, ``double`` and ``char*`` (strings).  Thus, you can only use these
    three data types in format strings for printf, scanf and the like.

:Call: value1, value2, ... = sscanf(vi, buffer, read_format, ...,
       maximal_string_length = 1024)
:VISA name: viSScanf
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `buffer` : string
        Buffer from which data is read and formatted.
    `read_format` : string
        String describing the format for arguments.
    `...` : integers, floats, or strings
        Arguments to be read from the device according to `read_format`.  It's
	totally insignificant which values they have, they serve just as a
	cheap way to determine what types are to be expected.  So actually this
	argument list shouldn't be necessary, but with the current
	implementation, it is, sorry.

        These arguments may be (however needn't be) the same names used for
	storing the result values.  Alternatively, you can give literals.
    `maximal_string_length` : integer : keyword argument
        The maximal length assumed for string result arguments.  Note that
	string results must *never* exceed this length.  It defaults to 1024.
:Return values:
    `value1`, `value2`, ... : integers, floats, or strings
        Arguments read from the device according to `read_format`.  Of course,
	this must be the same sequence (as far as data types are concerned) as
	the given argument list `...` above.


status_description
..................

Return a user-readable description of the status code passed to the operation.

:Call: description = status_description(vi, status)
:VISA name: viStatusDesc
:Parameters:
    `vi` : ViSession, ViEvent, or ViFindList
        Unique logical identifier to a session.
    `status` : integer
        Status code to interpret.
:Return values:
    `description` : string
        The user-readable string interpretation of the status code passed to
	the operation.


terminate
.........

Request a VISA session to terminate normal execution of an operation.

:Call: terminate(vi, degree, job_id)
:VISA name: viterminate
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `degree` : integer
        ``VI_NULL``
    `job_id` : ViJobId
        Specifies an operation identifier.
:Return values:
    None.


uninstall_handler
.................

Uninstall handlers for events.

:Call: uninstall_handler(vi, event_type, handler, user_handle)
:VISA name: viUninstallHandler
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `event_type` : integer
        Logical event identifier.
    `handler` : ViHndlr
        Interpreted as a valid reference to a handler to be uninstalled by a
	client application.
    `user_handle` : integer : optional
        A value specified by an application that can be used for identifying
	handlers uniquely in a session for an event.
:Return values:
    None.


unlock
......

Relinquish a lock for the specified resource.

:Call: unlock(vi)
:VISA name: viUnlock
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
:Return values:
    None.


unmap_address
.............

:Call: unmap_address(vi)
:VISA name: viunmap_address
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    visa_library().viUnmapAddress(vi)


unmap_trigger
.............

:Call: unmap_trigger(vi, trigger_source, trigger_destination)
:VISA name: viUnmapTrigger
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `trigger_sourcer` : integer
        Source line used in previous map.
    `trigger_destination` : integer
        Destination line used in previous map.
:Return values:
    None.


usb_control_in
..............

Request arbitrary data from the USB device on the control port.

:Call: buffer = usb_control_in(vi, request_type_bitmap_field,
		   request_id, request_value, index, length)
:VISA name: viUsbControlIn
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `request_type_bitmap_field` : integer
        Bitmap field for defining the USB control port request.  The bitmap
        fields are as defined by the USB specification.  The direction bit must
        be device-to-host.
    `request_id` : integer
        Request ID for this transfer.  The meaning of this value depends on
        `request_type_bitmap_field`.
    `request_value` : integer
        Request value for this transfer.
    `index` : integer
        Specifies the interface or endpoint index number, depending on
        `request_type_bitmap_field`.
    `length` : integer : optional
        Number of data in bytes to request from the device during the Data
        stage.  If this value is not given or 0, an empty string is returned.
:Return values:
    `buffer` : string
        Actual data received from the device during the Data stage.  If
        `length` is not given or 0, an empty string is returned.


usb_control_out
...............

Send arbitrary data to the USB device on the control port.

:Call: usb_control_out(vi, request_type_bitmap_field, request_id, request_value,
		    index, buffer)
:VISA name: viUsbControlOut
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `request_type_bitmap_field` : integer
        Bitmap field for defining the USB control port request.  The bitmap
        fields are as defined by the USB specification.  The direction bit must
        be host-to-device.
    `request_id` : integer
        Request ID for this transfer.  The meaning of this value depends on
        `request_type_bitmap_field`.
    `request_value` : integer
        Request value for this transfer.
    `index` : integer
        Specifies the interface or endpoint index number, depending on
        `request_type_bitmap_field`.
    `buffer` : string : optional
        Actual data to send to the device during the Data stage.  If not given,
        nothing is sent.
:Return values:
    None.


vprintf, vqueryf, vscanf, vsprintf, vsscanf
...........................................

These variants make no sense in Python, so I realised them as mere aliases
(just drop the "v").


vxi_command_query
.................

:Call: vxi_command_query(vi, mode, command)
:VISA name: vivxi_command_query
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `` : integer
:Return values:
    None.

    response = ViUInt32()
    visa_library().viVxiCommandQuery(vi, mode, command, byref(response))
    return response.value


wait_on_event
.............

Wait for an occurrence of the specified event for a given session.

:Call: out_event_type, out_context = wait_on_event(vi, in_event_type, timeout)
:VISA name: viWaitOnEvent
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `in_event_type` : integer
        Logical identifier of the event(s) to wait for.
    `timeout` : integer
        Absolute time period in milliseconds that the resource shall wait for a
	specified event to occur before returning the time elapsed error.
:Return values:
    `out_event_type` : integer
        Logical identifier of the event actually received.
    `out_context` : ViEvent
        A handle specifying the unique occurrence of an event.


write
.....

Write data to device synchronously.

:Call: return_count = write(vi, buffer)
:VISA name: viWrite
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `buffer` : string
        Contains the data block to be sent to the device.
:Return values:
    `return_count` : integer
        The number of bytes actually transferred.


write_asynchronously
....................

Write data to device asynchronously.

:Call: job_id = write_asynchronously(vi, buffer)
:VISA name: viWriteAsync
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `buffer` : string
        Contains the data block to be sent to the device.
:Return values:
    `job_id` : ViJobId
        The job identifier of this asynchronous write operation.


write_from_file
...............

Take data from a file and write it out synchronously.

:Call: return_count = write_from_file(vi, filename, count)
:VISA name: viWriteFromFile
:Parameters:
    `vi` : ViSession
        Unique logical identifier to a session.
    `filename` : string
        Name of file from which data will be read.
    `count` : integer
        Maximal number of bytes to be written.
:Return values:
    `return_count` : integer
        Number of bytes actually transferred.


..  LocalWords:  rst british vpp PyVISA ies dll
