% -*- mode: LaTeX; coding: utf-8; ispell-local-dictionary: "british"; -*-
% 
%   pyvisa.tex - Manual for high-level OO instrument access on top of VISA
% 
%   Copyright Â© 2005 Gregor Thalhammer <gth@users.sourceforge.net>,
%                    Torsten Bronger <bronger@physik.rwth-aachen.de>.
% 
%   This file is part of PyVISA.
% 
%   PyVISA is free software; you can redistribute it and/or modify it under
%   the terms of the GNU General Public License as published by the Free
%   Software Foundation; either version 2 of the License, or (at your option)
%   any later version.
% 
%   PyVISA is distributed in the hope that it will be useful, but WITHOUT ANY
%   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
%   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
%   details.
% 
%   You should have received a copy of the GNU General Public License along
%   with PyVISA; if not, write to the Free Software Foundation, Inc., 59
%   Temple Place, Suite 330, Boston, MA 02111-1307 USA
% 

\documentclass{howto}

\title{PyVISA}
\release{0.9.1}

\author{Torsten Bronger}
\authoraddress{
	Aachen, Germany\\
	\email{bronger@physik.rwth-aachen.de}
}

\date{3 Juli 2005}

\makeindex

\begin{document}

\maketitle

\ifhtml
\chapter*{Front Matter\label{front}}
\fi

Copyright \copyright{} 2005 Torsten Bronger.\\
Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version~1.2 or any later version
published by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts.  A copy of the license is included
as a separate file \file{LICENSE} in the PyVISA distribution.

\begin{abstract}

\noindent
PyVISA enables you to control your measurement and test equipment -- digital
multimeters, motors, sensors and the like.  This document covers the
simple-to-use \module{pyvisa} module of the PyVISA package.  It implements
control of measurement devices in a straightforward and convenient way.  The
design goal is to combine HTBasic's ease and implicitness with Python's modern
syntax and powerful set of libraries.  Please also have a look at
\ulink{PyVISA's project page}{http://sourceforge.net/projects/pyvisa} with bug
tracker and download area.

However, it is not a full VISA implementation because it relies on an external
VISA DLL or ``shared object'' file.  This can be downloaded from your interface
vendor's web pages (National Instruments, Agilent etc).  PyVISA only makes it
available for Python code.

This package is still under construction.  In particular, I need feedback from
people who've given it a try.  It works for us, but probably we are not
representative.
\end{abstract}

\begin{samepage}
  \tableofcontents
\end{samepage}

\declaremodule{extension}{pyvisa}
  \platform{Linux,Windows}
\modulesynopsis{Controlling measurement and test equipment using VISA.}
\moduleauthor{Gregor Thalhammer}{gth@users.sourceforge.net}
\moduleauthor{Torsten Bronger}{bronger@physik.rwth-aachen.de}
\sectionauthor{Torsten Bronger}{bronger@physik.rwth-aachen.de}

\section{An example}

Let's go \emph{in medias res} and have a look at a simple example:
\begin{verbatim}
from visa import *

my_instrument = GpibInstrument(14)
my_instrument.write("*IDN?")
print my_instrument.read()
\end{verbatim}
This example already shows the two main design goals of PyVISA: preferring
simplicity over generality, and doing it the object-oriented way.

Every instrument is represented in the source by an object instance.  In this case,
I have a GPIB instrument with instrument number~14, so I create the instance
(i.\,e.\ variable) called \var{my_instrument} accordingly:
\begin{verbatim}
my_instrument = GpibInstrument(14)
\end{verbatim}
Then, I send the message ``*IDN?''\ to the device, which is the standard GPIB
message for ``what are you?''\ or -- in some cases -- ``what's on your display
at the moment?'':
\begin{verbatim}
my_instrument.write("*IDN?")
\end{verbatim}
Finally, I print the instrument's answer on the screen:
\begin{verbatim}
print my_instrument.read()
\end{verbatim}


\subsection{Example for serial (RS232) device}

The only RS\,232 device in my lab is an old Oxford ITC\,4 temperature
controller, which is connected through COM\,2 with my computer.  The following
code prints its self-identification on the screen:
\begin{verbatim}
from visa import *

itc4 = Instrument("COM2", term_chars = "\r")
itc4.write("V")
print itc4.read()
\end{verbatim}


\subsection{A more complex example}
\label{sec:more-complex-example}

The following code works for a Keithley 2000 multimeter in ``language 199
mode'' (in contrast to ``SCPI mode'').  It advises the multimeter to measure
10~voltages.  After having read them, the program calculates the average
voltage and prints it on the screen.
\begin{verbatim}
from visa import GpibInstrument

keithley = GpibInstrument(12)
interval_in_ms = 500
number_of_readings = 10
keithley.write("F0B2M2G0T2Q%dI%dX" % (interval_in_ms, number_of_readings))
keithley.trigger()
keithley.wait_for_srq()
voltages = keithley.read_floats()
print "Average voltage: ", sum(voltages) / len(voltages)
\end{verbatim}
Let's have a look at the command string \code{"F0B2M2G0T2Q\%dI\%dX"}:
\begin{tableii}{ll}{code}{Code}{Description}
  \lineii{F0}{we want to measure \emph{voltages}}
  \lineii{B2}{we want to read the entire data buffer}
  \lineii{M2}{send SRQ when finished measuring}
  \lineii{G0}{neat number format}
  \lineii{T2}{start when triggered}
  \lineii{Q\%d}{set number of readings}
  \lineii{I\%d}{set time interval between readings}
  \lineii{X}{execute all commands}
\end{tableii}

After this string has been sent to the device, we start the measurement with
\begin{verbatim}
keithley.trigger()
\end{verbatim}
and wait for the end of data acquisition with
\begin{verbatim}
keithley.wait_for_srq()
\end{verbatim}
Now I must read the result from the device.  I could use the \code{read()}
method as in the first example, but then I'd get one big string,
\begin{verbatim}
NDCV-000.0004E+0,NDCV-000.0005E+0,NDCV-000.0004E+0,NDCV-000.0007E+0,
NDCV-000.0000E+0,NDCV-000.0007E+0,NDCV-000.0008E+0,NDCV-000.0004E+0,
NDCV-000.0002E+0,NDCV-000.0005E+0
\end{verbatim}
which I would have to convert to a list of numbers.  Fortunately, the
\code{read_floats()} method does this work for us, and so the variable
\var{voltages} contains
\begin{verbatim}
[-0.0004, -0.0005, -0.0004, -0.0007, 0, -0.0007, -0.0008, -0.0004,
 -0.0002, -0.0005]
\end{verbatim}
which is much better.  The rest of the example is straightforward Python.


\section{Module classes}

\subsection{General devices}
\label{sec:general-devices}

\begin{classdesc}{Instrument}{resource_name\optional{, **keyw}}
  represents an instrument, e.\,g.\ a measurement device.  It is independent of
  a particular bus system, i.\,e.\ it may be a GPIB, serial, USB, or whatever
  instrument.  However, it is not possible to perform bus-specific operations
  on instruments created by this class.  For this, have a look at the
  specialised classes like \class{GpibInstrument}
  (section~\ref{sec:gpib-devices}).

  The parameter \var{resource_name} takes the same syntax as resource
  specifiers in VISA\@.  Thus, it begins with the bus system followed by
  ``\verb|::|'', continues with the location of the device within the bus
  system, and ends with an optional ``\verb|::INSTR|''.

  Possible keyword arguments are:
  \begin{tableii}{ll}{var}{Keyword}{Description}
    \lineii{term_char}{termination characters, see
      section~\ref{sec:termchars}. Default: \code{""} \emph{(empty)}}
    \lineii{timeout}{timeout in seconds for all device operations, see
      section~\ref{sec:timeouts}. Default:~2}
    \lineii{chunk_size}{Length of read data chunks in bytes, see
      section~\ref{sec:chunk-length}. Default: 20\,kB}
    \lineii{lock}{whether you want to have exclusive access to the device.
      Default: \code{VI_NO_LOCK}}
  \end{tableii}

  \vspace{1ex}
  For further information about the locking mechanism,
  see~\citetitle[http://pyvisa.sourceforge.net/vpp43.html]{The VISA library
    implementation}.
\end{classdesc}

For example, the above mentioned GPIB instrument with number~14 could also be
created with
\begin{verbatim}
my_instrument = Instrument("GPIB::14")
\end{verbatim}
or even more explicitly with
\begin{verbatim}
my_instrument = Instrument("GPIB0::14::INSTR")
\end{verbatim}

The class \class{Instrument} defines the following methods and attributes:

\begin{methoddesc}{write}{message}
  writes the string \var{message} to the instrument.
\end{methoddesc}

\begin{methoddesc}{read}{}
  returns a string sent from the instrument to the computer.
\end{methoddesc}

\begin{methoddesc}{read_floats}{}
  returns a list of decimal values (floats) sent from the instrument to the
  computer.  See section~\ref{sec:more-complex-example} above.  If only one
  value has been found, it is returned as such (i\,e.\ not as a list), and if
  no float has been found, \code{None} is returned.
\end{methoddesc}

\begin{methoddesc}{clear}{}
  resets the device.  This operation is highly bus-dependent.  I refer you to
  the original VISA documentation, which explains how this is achieved for VXI,
  GPIB, serial, etc.
\end{methoddesc}

\begin{memberdesc}{timeout}
  The timeout in seconds for each I/O operation.  See
  section~\ref{sec:timeouts} for further information.
\end{memberdesc}

\begin{memberdesc}{term_chars}
  The termination characters for each read and write operation.  See
  section~\ref{sec:termchars} for further information.
\end{memberdesc}


\subsection{GPIB devices}
\label{sec:gpib-devices}

\begin{classdesc}{GpibInstrument}{gpib_identifier\optional{,
      board_number\optional{, **keyw}}}
  represents a GPIB instrument.  If \var{gpib_identifier} is a string, it is
  interpreted as a VISA resource name.  If it is a number, it denotes the
  device number at the GPIB bus.

  The optional \var{board_number} defaults to zero.  If you have more that one
  GPIB bus system attached to the computer, you can select the bus with this
  parameter.

  The keyword arguments are interpreted the same as with the class
  \class{Instrument}.
\end{classdesc}

\begin{notice}
  Since this class is derived from the class \class{Instrument}, please refer
  to section~\ref{sec:general-devices} for the basic operations.
  \class{GpibInstrument} can do everything that \class{Instrument} can do, so
  it simply extends the original class with GPIB-specific operations.
\end{notice}

The class \class{GpibInstrument} defines the following methods:

\begin{methoddesc}{wait_for_srq}{\optional{timeout}}
  waits for a serial request (SRQ) coming from the instrument.  Note that this
  method is not ended when \emph{another} instrument signals an SRQ, only
  \emph{this} instrument.
  
  The \var{timeout} argument, given in seconds, denotes the maximal waiting
  time.  The default value is 25~(seconds).  If you pass \code{None} for the
  timeout, this method waits forever if no SRQ arrives.
\end{methoddesc}

\begin{methoddesc}{trigger}{}
  sends a trigger signal to the instrument.
\end{methoddesc}

\bigskip
\begin{classdesc}{Gpib}{\optional{board_number}}
  represents a GPIB board.  Although most setups have at most one GPIB
  interface card or USB-GPIB device (with board number~0), theoretically you
  may have more.  Be that as it may, for board-level operations, i.\,e.\
  operations that affect the whole bus with all connected devices, you must
  create an instance of this class.

  The optional GPIB board number \var{board_number} defaults to~0.
\end{classdesc}

The class \class{Gpib} defines the following method:

\begin{methoddesc}{send_ifc}{}
  pulses the interface clear line (IFC) for at least 0.1~seconds.
\end{methoddesc}

\begin{notice}
You needn't store the board instance in a variable.  Instead, you may send an
IFC signal just by saying \samp{Gpib().send_ifc()}.
\end{notice}


\subsection{Termination characters}
\label{sec:termchars}

Somehow the computer must detect when the device is finished with sending a
message.  It does so by using different methods, depending on the bus system.
However, you may influence this behaviour by setting termination characters.

Termination characters may be one character or a sequence of characters.
Whenever this character or sequence occurs in the input stream, the read
operation is terminated and the read message is given to the calling
application.  The next read operation continues with the input stream
immediately after the last termination sequence.  In PyVISA, the termination
characters are stripped off the message before it is given to you.

You may set termination characters for each instrument, e.\,g.
\begin{verbatim}
my_instrument.term_chars = "\r"
\end{verbatim}
Alternatively you can give it when creating your instrument object:
\begin{verbatim}
my_instrument = Instrument("GPIB::10", term_chars = "\r")
\end{verbatim}
The default value depends on the bus system.  Generally, the sequence is empty.
For GPIB instruments however, it's set to \verb|"\r\n"| (i.\,e.~``CR\,LF'')\@.
For RS232 (once it's supported), it's just \verb|"\n"|~(LF)\@.

You may add two options to the termination characters: \code{NOEND} and
\code{DELAY}.  They are inspired by HTBasic.  \code{NOEND} makes only sense for
GPIB instruments.  It switches off detection of the end of a message using the
EOI bus line.  (This means that by default the observance of this line is on.)

\code{DELAY} takes a numeric argument that denotes the time in seconds to wait
after each write operation.  So you could write:
\begin{verbatim}
my_instrument = Instrument("GPIB::10", term_chars = "\r NOEND DELAY 1.2")
\end{verbatim}
This will set the delay to 1.2~seconds, and the EOI line is ignored.  Note that
spaces before the options are ignored, and that at least one space must be
there, unless the termination sequence itself is empty.  So, \code{"\e
  rNOEND"}, \code{" NOEND"}, and \code{"noend"} are all illegal in the sense
that they will be interpreted as one long termination sequence, which is
probably not what you want.  The correct variants are \code{"\e r NOEND"},
\code{"NOEND"}, and \code{"NOEND"}.


\subsection{Timeouts}
\label{sec:timeouts}

Very most VISA I/O operations may be performed with a timeout.  If a timeout is
set, every operation that takes longer than the timeout is aborted and an
exception is raised.  Timeouts are given per instrument.

For all PyVISA objects, a timeout is set with
\begin{verbatim}
my_device.timeout = 25
\end{verbatim}
Here, \var{my_device} may be a device, an interface or whatever, and its
timeout is set to 25~seconds.  Floating-point values are allowed.  If you set
it to zero, all operations must succeed instantaneously.  You must not set it
to \code{None}.  Instead, if you want to remove the timeout, just say
\begin{verbatim}
del my_device.timeout
\end{verbatim}
Now every operation of the resource takes as long as it takes, even
indefinitely if necessary.

The default timeout is 2~seconds, but you can change it when creating the
device object:
\begin{verbatim}
my_instrument = Instrument("ASRL1", timeout = 5)
\end{verbatim}
This creates the object variable \var{my_instrument} and sets its timeout to
5~seconds.  In this context, a timeout value of \code{None} is allowed, which
removes the timeout for this device.


\subsection{Chunk length}
\label{sec:chunk-length}

If you read data from a device, you must store it somewhere.  Unfortunately,
PyVISA must make space for the data \emph{before} it starts reading, which
means that it must know how much data the device will send.  However, it
doesn't know a~priori.

Therefore, PyVISA reads from the device in \emph{chunks}.  Each chunk is
20~kilobytes long by default.  If there's still data to be read, PyVISA repeats
the procedure and eventually concatenates the results and returns it to you.
By the way, those 20~kilobytes are large enough so that mostly one read cycle
is sufficient.

The whole thing happens automatically, as you can see.  Normally you needn't
worry about it.  However, some devices doesn't like to send data in chunks.  So
if you have trouble with a certain device and expect data lengths larger than
the default chunk length, you should increase its value by saying
\begin{verbatim}
my_instrument.chunk_size = 102400
\end{verbatim}
This example sets it to 100~kilobytes.


\section{Module functions}

\begin{funcdesc}{get_instruments_list}{\optional{use_aliases}}
  returns a list with all instruments that are known to the local VISA system.
  If you're lucky, these are all instruments connected with the computer.

  The boolean \var{use_aliases} is \code{True} by default, which means that the
  more human-friendly aliases like ``\code{COM1}'' instead of ``\code{ASRL1}''
  are returned.  With some VISA systems\footnote{such as the ``Measurement and
    Automation Center'' by National Instruments} you can define your own
  aliases for each device, e.\,g.\ ``\code{keithley617}'' for
  ``\code{GPIB0::15::INSTR}''.  If \var{use_aliases} is \code{False}, only
  standard resource names are returned.
\end{funcdesc}


\section{Mixing with direct VISA commands}

You can mix the high-level object-oriented approach described in this document
with middle-level VISA function calls in module \module{vpp43} as described in
\citetitle[http://pyvisa.sourceforge.net/vpp43.html]{The VISA library
  implementation} which is also part of the PyVISA package.  By doing so, you
have full control of your devices.  I recommend to import the VISA functions
with
\begin{verbatim}
from pyvisa import vpp43
\end{verbatim}
Then you can use them with \samp{vpp43.\emph{function_name}(...)}.

The VISA functions need to know what session you are referring to.  PyVISA
opens exactly one session for each instrument or interface and stores its
session handle in the instance attribute~\member{vi}.  For example, these two
lines are equivalent:
\begin{verbatim}
my_instrument.clear()
vpp43.clear(my_instrument.vi)
\end{verbatim}

In case you need the session handle for the default resource manager, it's
stored in \member{resource_manager.session}:
\begin{verbatim}
from visa import *
from pyvisa import vpp43
my_instrument_handle = vpp43.open(resource_manager.session, "GPIB::14",
                                  VI_EXCLUSIVE_LOCK)
\end{verbatim}

\section{Installation}

\subsection{Prerequisites}

PyVISA needs Python version~2.3 or newer.

The PyVISA package doesn't include a low-level VISA implementation itself.  You
have to download it from one of the VISA vendors, e.\,g.\ from the
\ulink{National Instruments VISA pages}{http://ni.com/visa/}.  Please install
it properly before you proceed.

Additionally, your Python installation needs a fresh version of
\ulink{ctypes}{http://starship.python.net/crew/theller/ctypes/}.  By the way,
if you use Windows, it may be convenient to install \ulink{Enthought
  Python}{http://www.enthought.com/python/}.  It is a special Python version
with all-included philosophy for scientific and engineering
applications.\footnote{Of course, it's highly advisable not to have installed
  another version of Python on your system before you install Enthought
  Python.}


\subsection{Setting up the module}

\subsubsection{Windows}

PyVISA expects a file called \file{visa32.dll} in the \envvar{PATH}\@.  You
must assure that this is the case.  For example, on my system you find this
file in \file{C:\e WINNT\e system32\e}.  Either copy it there or expand your
\envvar{PATH}\@.


\subsubsection{Linux}

For Linux, the default VISA library is
\file{/usr/local/vxipnp/linux/bin/libvisa.so.7}.  However, here you have the
choice.  If it's called differently on your system, or is placed in another
directory, you can tell PyVISA by creating a file \file{~/.pyvisarc}.  This has
the format of an INI~file.  For example, if the library is at
\file{/usr/lib/libvisa.so.7}, the file \file{.pyvisarc} must contain the
following:
\begin{verbatim}
[Paths]

VISA library: /usr/lib/libvisa.so.7
\end{verbatim}
Please note that ``\code{[Paths]}'' is treated case-sensitively.

You can define a site-wide configuration file at
\file{/usr/share/pyvisa/.pyvisarc}.  (It may also be \file{/usr/local/\ldots}\
depending on the location of your Python.)


\section{About PyVISA}

PyVISA was originally programmed by Gregor Thalhammer, Innsbruck/Austria, and
Torsten Bronger, Aachen/\hskip0pt Germany.  It bases on earlier experiences by
Thalhammer.

Its homepage is \url{http://sourceforge.net/projects/pyvisa/}.  Please report
bugs there.  \textbf{I'm also very keen to know whether PyVISA works for you or
  not.  Thank you!}

\end{document}

% LocalWords:  ascii british PyVISA pyvisa keyw GpibInstrument var NOEND EOI
% LocalWords:  rNOEND noend ASRL keithley gpib Center vpp ctypes dll WINNT IDN
% LocalWords:  ifc SCPI srq utf tex pyvisarc INI ITC
